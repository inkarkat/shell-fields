#!/bin/bash
shopt -qs extglob

printShortUsage()
{
    # Note: short followed by long option; if the user knows the short one, she can
    # skim the long one.
    printf 'Usage: cat FILE [...] | %q %s\n' "$(basename "$1")" '[-F|--field-separator FS] [-u|--unbuffered] [-]N AWK-EXPR [...]'
    echo
    printf 'Usage: %q %s\n' "$(basename "$1")" '... [-i[SUFFIX]|--in-place[=SUFFIX]] [-]N AWK-EXPR | "[AWK-EXPR]|COMMAND" [...] [--] [FILE ...] [-?|-h|--help]'
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 '\nTry %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    # This is the long "man page" when launched with the help argument.
    # It is printed to stdout to allow paging with 'more'.
    cat <<HELPDESCRIPTION
Transform a field N (-N counted from behind) with AWK-EXPR. Application happens
in argument order from left to right; when multiple expressions target the same
field, each is applied once.
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    echo
    cat <<HELPTEXT
    AWK-EXPR		    Any valid expression in AWK, for example 42,
			    '"foo"', '++\$fieldNr' (fieldNr refers to N), or
			    '\$1 "(" length(\$1) ")"')
    "|COMMAND"		    Start COMMAND as a coprocess. The original contents
			    of the target field are written to COMMAND's
			    standard input, and one resulting line is read back
			    and replaces the field's contents. So command must
			    respond with one output line for each input line,
			    without buffering.
    "AWK-EXPR|COMMAND"	    Start COMMAND as a coprocess. For each target field,
			    the AWK-EXPR is written to COMMAND's standard input,
			    and one resulting line is read back and replaces
			    the field's contents.
			    So whereas |COMMAND transforms a particular field,
			    this form allows to synthesize a field from other
			    fields.
    --field-separator|-F FS Use FS as the input field separator (as with AWK).
    --unbuffered|-u	    Immediately output each read line.
    --in-place[=SUFFIX]|-i[SUFFIX]
			    Edit FILE(s) in place (makes backup if SUFFIX
			    supplied).
EXIT STATUS:
    0	Complete success.
    1	AWK processing error.
    2	Bad invocation, wrong or missing command-line arguments.
    3	Internal error or failed assertion.

Example:
HELPTEXT
    printf '%q %s\n' "$(basename "$1")" "-1 '\$fieldNr \" (\" NF \")\"' -- /tmp/foobar"
}


isBuffered=t
typeset -a awkCall=(awk)
typeset -a awkArgs=()
typeset -a fields=()
typeset -a expressionCode=()
typeset -a coprocs=()
isInPlace=
inPlaceExtension=
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)		shift; printLongUsage "$0"; exit 0;;
	--field-separator|-F)	awkArgs+=("$1" "$2"); shift; shift;;
	--unbuffered|-u)	shift; isBuffered=;;
	-i|--in-place)		isInPlace=t; shift;;
	-i?*|--in-place=*)	isInPlace=t; inPlaceExtension="${1#-i}"; inPlaceExtension="${inPlaceExtension#--in-place=}"; shift;;
	?(-)+([0-9]))		fields+=("$1")
				awkExpr="$2"
				if [[ "$awkExpr" =~ ^([^|]*)\|(.*)$ ]]; then
				    coprocs+=("${BASH_REMATCH[2]}")
				    awkSourceExpr="${BASH_REMATCH[1]}"; [ -n "$awkSourceExpr" ] || awkSourceExpr='$fieldNr'
				    printf -v awkExpr 'pipeThrough(%s, coprocs[%d])' "$awkSourceExpr" "${#coprocs[@]}"
				fi

				case "$1" in
				    -*)	expressionCode+=("if (fieldNr == NF - ${1#-} + 1 && --fieldNrSequence == 0) return $awkExpr");;
				    *)	expressionCode+=("if (fieldNr == $1 && --fieldNrSequence == 0) return $awkExpr");;
				esac
				shift; shift
				;;
	--)			shift; break;;
	-*)			{ echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)			break;;
    esac
done
if [ ${#fields[@]} -eq 0 ]; then
    echo 'ERROR: No [-]N AWK-EXPR passed.'
    echo
    printUsage "$0"
    exit 2
fi >&2
if [ "$isInPlace" ]; then
    awkCall=(gawk -i inplace -v "INPLACE_SUFFIX=$inPlaceExtension" -v "inplace::suffix=$inPlaceExtension")
fi

IFS=$'\n'
exec "${awkCall[@]}" "${awkArgs[@]}" \
    -v "isBuffered=$isBuffered" \
    -v "fieldList=${fields[*]//\\/\\\\}" \
    -v "coprocList=${coprocs[*]//\\/\\\\}" \
'
function pipeThrough(input, coproc,      result)
{
    print input |& coproc
    coproc |& getline result
    return result
}
function evaluateExpression(fieldNr, fieldNrSequence)
{
'"${expressionCode[*]}"'
    printf "ASSERT: Expression for field %d did not match.", fieldNr > "/dev/stderr"
    exit(3)
}
function getFieldNr(field)
{
    field = 0 + field
    return (field < 0 ? NF + field + 1 : field)
}
function insert(fieldNr, expression,      i)
{
    for (i = NF; i > fieldNr; --i) {
	$(i + 1) = $i
    }
    $(fieldNr + 1) = expression
}
BEGIN {
    # Return dict sorted by fieldNumbers, from right to left.
    PROCINFO["sorted_in"] = "@ind_num_desc"

    N = split(fieldList, fields, "\n")
    split(coprocList, coprocs, "\n")
}
NR == 1 {
    # Use FS as output separator; it cannot be a regular expression here.
    firstTwoFields = $1 FS $2
    if (NF < 2 || substr($0, 1, length(firstTwoFields)) == firstTwoFields) {
	OFS = FS
    } else if (FS == " ") {
	OFS = ((substr($0, 1, length(firstTwoFields)) == $1 "\t" $2) ? "\t" : " ")
    } else {
	print "ERROR: The field separator has to be a literal string; it cannot be a regular expression." > "/dev/stderr"
	exit 2
    }
}
{
    delete fieldNrSequences
    for (n = 1; n <= N; ++n) {
	fieldNr = getFieldNr(fields[n])
	if (fieldNr >= 1) {
	    $fieldNr = evaluateExpression(fieldNr, ++fieldNrSequences[fieldNr])
	}
    }

    print
    if (! isBuffered) fflush()
}
' "$@"
